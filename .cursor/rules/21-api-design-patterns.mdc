---
globs: "backend/app/api/**/*.py"
---

# API Design Patterns

## RESTful Conventions

Follow RESTful conventions in [backend/app/api/v1/endpoints/](mdc:backend/app/api/v1/endpoints/):

- Use HTTP methods correctly: GET, POST, PUT, DELETE
- Use proper status codes
- Use resource-based URLs
- Use consistent naming (kebab-case for URLs, snake_case for Python)

## Endpoint Structure

```
POST   /api/v1/auth/login       # Authenticate
GET    /api/v1/auth/verify      # Verify token
GET    /api/v1/notes/           # List all notes
GET    /api/v1/notes/{path}     # Get note
POST   /api/v1/notes/{path}     # Create note
PUT    /api/v1/notes/{path}     # Update note
DELETE /api/v1/notes/{path}     # Delete note
POST   /api/v1/notes/{path}/move  # Move note
```

## HTTP Status Codes

Use appropriate status codes:

- `200 OK` - Successful GET, PUT, PATCH, DELETE
- `201 Created` - Successful POST that creates resource
- `400 Bad Request` - Invalid input
- `401 Unauthorized` - Not authenticated
- `403 Forbidden` - Authenticated but not authorized
- `404 Not Found` - Resource doesn't exist
- `500 Internal Server Error` - Server error

Example:
```python
from fastapi import HTTPException

@router.get("/api/v1/notes/{path}")
async def get_note(path: str):
    if not os.path.exists(resolved_path):
        raise HTTPException(status_code=404, detail="Note not found")
    
    try:
        with open(resolved_path, 'r') as f:
            content = f.read()
    except Exception:
        raise HTTPException(status_code=500, detail="Error reading file")
    
    return {"content": content}
```

## Error Handling

Always return meaningful error messages:

```python
try:
    operation()
except FileNotFoundError:
    raise HTTPException(status_code=404, detail="File not found")
except PermissionError:
    raise HTTPException(status_code=403, detail="Permission denied")
except ValueError as e:
    raise HTTPException(status_code=400, detail=str(e))
except Exception as e:
    raise HTTPException(status_code=500, detail="Internal server error")
```

## Pydantic Models

Use Pydantic for request/response validation:
```python
from pydantic import BaseModel
from typing import Optional

class NoteResponse(BaseModel):
    path: str
    content: str
    modified_at: datetime
    
class CreateNoteRequest(BaseModel):
    path: str
    content: str
    
class UpdateNoteRequest(BaseModel):
    content: str

@router.post("/api/v1/notes/{path}")
async def create_note(
    path: str,
    request: CreateNoteRequest
) -> NoteResponse:
    # Implementation
```

## OpenAPI Documentation

FastAPI auto-generates OpenAPI docs at `/docs`:
- Use docstrings for endpoint descriptions
- Add summary and description fields
- Document request/response models
- Add example responses

Example:
```python
@router.get(
    "/api/v1/notes/{path}",
    summary="Get note content",
    response_model=NoteResponse
)
async def get_note(path: str):
    """Get content of a specific note file.
    
    Returns the full content of the markdown file at the given path.
    """
    # Implementation
```